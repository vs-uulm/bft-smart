/* * Copyright (c) 2007-2013 Alysson Bessani, Eduardo Alchieri, Paulo Sousa,  * and the authors indicated in the @author tags  *   * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */package navigators.smart.communication;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Collections;import java.util.EnumMap;import java.util.Map;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import java.util.logging.Level;import java.util.logging.Logger;import navigators.smart.communication.client.CommunicationSystemServerSide;import navigators.smart.communication.client.CommunicationSystemServerSideFactory;import navigators.smart.communication.client.RequestReceiver;import navigators.smart.communication.server.GlobalMessageVerifier;import navigators.smart.communication.server.MessageVerifierFactory;import navigators.smart.communication.server.PTPMessageVerifier;import navigators.smart.communication.server.ServersCommunicationLayer;import navigators.smart.tom.core.messages.SystemMessage;import navigators.smart.tom.core.messages.TOMMessage;import navigators.smart.tom.util.TOMConfiguration;/** * * @author alysson * @author Christian Spann  */ public class ServerCommunicationSystem extends Thread {    private static final Logger log = Logger.getLogger(ServerCommunicationSystem.class.getName());    public static int TOM_REQUEST_MSG = 1;    public static int TOM_REPLY_MSG = 2;    public static int PAXOS_MSG = 3;    public static int RR_MSG = 4;    public static int RT_MSG = 5;    private BlockingQueue<SystemMessage>[] inQueue = null;    private Semaphore msgIndicator = new Semaphore(0);    @SuppressWarnings("rawtypes")	protected Map<SystemMessage.Type,MessageHandler> msgHandlers = Collections.synchronizedMap(new EnumMap<SystemMessage.Type, MessageHandler>(SystemMessage.Type.class));    private final ServersCommunicationLayer serversConn;    private final CommunicationSystemServerSide clientsConn;    @SuppressWarnings("rawtypes")	private GlobalMessageVerifier verifier;        /**     * Boolean to control the nested thread     */    private volatile boolean running = true;    /** Latch to wait for termination of threads */    private final CountDownLatch finished = new CountDownLatch(1);    /**     * Creates a new instance of ServerCommunicationSystem     * @param conf The configuration object containing the conf     * @throws IOException     */    @SuppressWarnings({ "rawtypes", "unchecked" })	public ServerCommunicationSystem(TOMConfiguration conf) throws IOException  {        super("Server CS");                inQueue = new ArrayBlockingQueue[conf.getN()];        for (int i = 0; i < inQueue.length; i++) {        	inQueue[i] = new ArrayBlockingQueue<SystemMessage>(conf.getInQueueSize());		}        log.info("Inqueue size: "+conf.getInQueueSize());               MessageVerifierFactory<PTPMessageVerifier> ptpFactory = null;        switch (conf.getVerifierType()) {            case PTPVerifier:                ptpFactory = createVerifierFactory(conf.getPTPVerifierFactoryClassname());                assert ptpFactory != null : "Failed to load HMAC Factory";                break;            case GlobalVerifier:                verifier = (GlobalMessageVerifier) createVerifierFactory(conf.getGlobalMessageVerifierFactoryClassName()).generateMessageVerifier();                verifier.authenticateAndEstablishAuthKey();                assert verifier != null : "Failed to load USIG Service";                break;	    case None:                log.info("No verification is used");		break;	    default:		log.severe("Unknown verifier type specified!");        }                //create a new conf, with updated port number for servers        TOMConfiguration serversConf = new TOMConfiguration(conf,conf.getProcessId());        serversConf.increasePortNumber();        serversConn = new ServersCommunicationLayer(serversConf,inQueue, msgIndicator, msgHandlers,ptpFactory,verifier);        clientsConn = CommunicationSystemServerSideFactory.getCommunicationSystemServerSide(conf);        //start();    }        @Override    public synchronized void start(){//        setThreadPriority(this);    	setPriority(Thread.NORM_PRIORITY+3);    	log.info("Starting Servers Com System to accept and establish connections.");		serversConn.start();    	log.info("Started Servers Com System, starting inqueue handler (Server Com System)");    	super.start();    	log.info("Started inqueue handler (Server Com System)");    }    @SuppressWarnings({ "rawtypes", "unchecked" })    protected final MessageVerifierFactory createVerifierFactory(String algorithm){        Class<MessageVerifierFactory> serviceclass;        try {            serviceclass = (Class<MessageVerifierFactory>) Class.forName(algorithm);            Object[] initargs = new Object[0];            MessageVerifierFactory factory = (MessageVerifierFactory) serviceclass.getConstructors()[0].newInstance(initargs);            return factory;        } catch (InstantiationException ex) {            Logger.getLogger(ServerCommunicationSystem.class.getName()).log(Level.SEVERE, null, ex);        } catch (IllegalAccessException ex) {            Logger.getLogger(ServerCommunicationSystem.class.getName()).log(Level.SEVERE, null, ex);        } catch (IllegalArgumentException ex) {            Logger.getLogger(ServerCommunicationSystem.class.getName()).log(Level.SEVERE, null, ex);        } catch (InvocationTargetException ex) {            Logger.getLogger(ServerCommunicationSystem.class.getName()).log(Level.SEVERE, null, ex);        } catch (ClassNotFoundException ex) {            Logger.getLogger(ServerCommunicationSystem.class.getName()).log(Level.SEVERE, null, ex);        }        return null;    }    @SuppressWarnings("rawtypes")	public void addMessageHandler(SystemMessage.Type type, MessageHandler handler){        assert(msgHandlers.size()<=Byte.MAX_VALUE);        msgHandlers.put(type,handler);    }    public void setRequestReceiver(RequestReceiver requestReceiver) {        clientsConn.setRequestReceiver(requestReceiver);    }    /**     * Thread method resposible for receiving messages sent by other servers.     */    @Override    public void run() {		try {			int next = 0;			log.fine("Inqueue handler starts running");			while (running) {				try {					msgIndicator.acquire();					SystemMessage msg;					//Look for the next message in the queues;					while((msg = inQueue[next].poll()) == null){						next = incNext(next);					};					// find a handler to process the msg					msgHandlers.get(msg.type).processData(msg);					// select next					next = incNext(next);				} catch (InterruptedException ex) {					log.log(Level.FINE, "Got interrupted", ex);				}			}		} finally {			finished.countDown();			log.log(Level.FINE, "ComSystem finished");		}    }    /**     * Overrun proof alternative to modulo for rotating selection     * @param next     * @return     */	private int incNext(int next) {		next++;		if (next == inQueue.length) {			next = 0;		}		return next;	}	private void cleanUp() {		serversConn.shutdown();		clientsConn.shutdown();		msgHandlers.clear();		for (int i = 0; i < inQueue.length; i++) {			inQueue[i].clear();		}	}		/**     * Used to send messages.     *     * @param targets the target receivers of the message     * @param sm the message to be sent     */    public void send(Integer[] targets, SystemMessage sm) {		send(targets,sm,true);    }		/**     * Used to send messages.     *     * @param targets the target receivers of the message     * @param sm the message to be sent     * @param sign Shall the message be signed.     */    public void send(Integer[] targets, SystemMessage sm, boolean sign) {		if(log.isLoggable(Level.FINEST)){			log.log(Level.FINEST,"Sending message: {0} with length {1}",new Object[]{sm,sm.getMsgSize()});		}        if(sm.type.equals(SystemMessage.Type.TOM_MSG)) {            //Logger.println("(ServerCommunicationSystem.send) C: "+sm);            clientsConn.send(targets, (TOMMessage)sm);        } else {        	// Needs to be syncrhonized when using an usig factory         	synchronized (serversConn){	            //Logger.println("(ServerCommunicationSystem.send) S: "+sm);	            if(verifier != null && sign){	                verifier.generateHash(sm);	            }	            serversConn.send(targets, sm);        	}        }    }    @Override    public String toString() {        return serversConn.toString();    }		public String getQueueLengths(){		return serversConn.getQueueLengths();	}		public String getQueueNames() {		return serversConn.getQueueNames();	}    /**     * Checks if the "navigators.smart.communication.threadpriority" is set and     * sets this threads priority accordingly.     * If not a default value of 8 is used.     */    public static void setThreadPriority(Thread t) {    	String threadprio = System.getProperty("navigators.smart.communication.threadpriority");		if (threadprio != null) {			try {				int prio = Integer.parseInt(threadprio);				t.setPriority(prio);				return;			} catch (Exception e) {				log.log(Level.WARNING, "Failed to parse threadpriority: {0} ",						e.getMessage());			}		}       //set normal priority if System property is not set or invalid, so that       //the main thread can work properly       t.setPriority(Thread.NORM_PRIORITY+1);    }        /**     * Shuts down the nested thread.     */    public void shutdown(){    	running = false;    	this.interrupt();    	try {			finished.await(100, TimeUnit.MILLISECONDS);		} catch (InterruptedException e) {			log.severe("Interrupted while waiting for thread to finish");			e.printStackTrace();		}    	cleanUp();    }}